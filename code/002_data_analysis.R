################################################################################
# Author's information: 
# Alfredo Sanchez-Tojar (@ASanchez_Tojar)
# Profile: https://goo.gl/PmpPEB
# Department of Evolutionary Biology, Bielefeld University (GER) 
# Email: alfredo.tojar@gmail.com
# Script first created on the 25th of August 2021

################################################################################
# Description of script and Instructions
################################################################################

# This script imports the clean data generated by script 001_data_cleaning.R
# regarding data on bird wing length to calculate and analyse coefficient of 
# variations across species, and understand if differences across species can be
# explained by species-specific and population-specific differences in migratory 
# status and feeding type.

# For the study:

# Klaus Reinhold, Alfredo Sánchez-Tójar. 2025. Wing length canalisation and 
# behaviour across birds: a phylogenetic meta-analysis of variance

################################################################################
# Packages needed
################################################################################

# install.packages("pacman")
pacman::p_load(ape,metafor,rotl,
               treebase,diagram,dplyr,stringr,ggplot2,wesanderson,
               ggsignif,visdat,cowplot,viridis,
               patchwork, # nice resource page https://patchwork.data-imaginist.com/articles/guides/layout.html
               ggstance,ggtree,RColorBrewer,
               tidyverse,ggpubr,orchaRd,clubSandwich)

# cleaning environment
rm(list=ls())


################################################################################
# Functions: 
################################################################################

# function to calculate heterogeneity obtained from:
# https://github.com/Yefeng0920/heterogeneity_ecoevo/tree/main/function
# function to calculate heterogeneity - squared version, including CVH2 and M2
h.calc2 <- function(mod){
  # I2
  # sigma2_v = typical sampling error variance
  sigma2_v <- sum(1 / mod$vi) * (mod$k - 1) /
    (sum(1 / mod$vi)^2 - sum((1 / mod$vi)^2))
  # s^2_t = total variance
  I2_total <- 100 * (sum(mod$sigma2) / (sum(mod$sigma2) + sigma2_v))
  I2_each <- 100 * (mod$sigma2 / (sum(mod$sigma2) + sigma2_v))
  #names(I2_each) <- paste0("I2_", model$s.names)
  #names(I2_total) <- "I2_Total"
  I2s_Shinichi <- c(I2_total, I2_each)
  
  # matrix version  
  W <- solve(mod$V)
  X <- model.matrix(mod)
  P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
  I2_total2 <- 100* (sum(mod$sigma2) / (sum(mod$sigma2) + (mod$k - mod$p) / sum(diag(P))))
  I2_each2 <- 100* (mod$sigma2 / (sum(mod$sigma2) + (mod$k - mod$p) / sum(diag(P))))
  #names(I2_each2) <- paste0("I2_", model$s.names)
  #names(I2_total2) <- "I2_Total2"
  I2s_Wolfgang <- c(I2_total2, I2_each2)
  
  
  # CVH2
  CV_total <- (sum(mod$sigma2) / (mod$beta[1])^2)
  CV_each <- (mod$sigma2 / (mod$beta[1])^2)
  
  #names(CVB_each) <- paste0("CVB_", mod$s.names)
  #names(CVB_total) <- "CVB_total"
  CVHs <- c(CV_total, CV_each)
  
  # M2
  M_total <- (sum(mod$sigma2) / (sum(mod$sigma2) + (mod$beta[1])^2))
  M_each <- (mod$sigma2) / (sum(mod$sigma2) + (mod$beta[1])^2)
  Ms <- c(M_total, M_each)
  
  hs <- data.frame(I2s_Shinichi,CVHs,Ms)
  rownames(hs) <- c("Total", mod$s.names)
  return(hs)
}

# function to estimate typical sampling error variance obtained from 
# https://github.com/Yefeng0920/heterogeneity_ecoevo/tree/main/function
sigma2_v <- function(mod){
  sigma2_v <- sum(1 / mod$vi) * (mod$k - 1) /
    (sum(1 / mod$vi)^2 - sum((1 / mod$vi)^2))
  return(sigma2_v)
}


# function for extracting mean and CI from each metafor model
estimates.CI <- function(model){
  db.mf <- data.frame(model$b,row.names = 1:nrow(model$b))
  db.mf <- cbind(db.mf,model$ci.lb,model$ci.ub,row.names(model$b),model$pval)
  names(db.mf) <- c("mean","lower","upper","estimate","p-value")
  return(db.mf[,c("estimate","mean","lower","upper","p-value")])
}

################################################################################
# Importing the data 
################################################################################

# importing final dataset
body.CV.final <- read.csv("data/final/04_final_full_and_clean_bird_wing_size_dataset.csv",
                          header=T,sep=",")

# quick view
names(body.CV.final)
summary(body.CV.final)


# converting some variables types to factors
cols.factors <- c("population_ID","species.updated","species",
                  "study_ID","reference_link","subset",
                  "trait","unit","measurement_notes",
                  "pair_ID","sex","migratory","feeding.type",
                  "migratory.pop.level","feeding.type.pop.level",
                  "migratory.inc.vagrants.pop.level","migratory.inc.vagrants")

body.CV.final[cols.factors] <- lapply(body.CV.final[cols.factors], 
                                      factor)

summary(body.CV.final)


# adding the missing random effect variables needed for the analyses

# generating a new species variable to account for repeated values for some 
# species + phylogeny (sensu Cinar et al. 2020, MEE)
body.CV.final$species.updated.rep <- body.CV.final$species.updated

# generating a unit level effect to model residual/within-study variance
body.CV.final$effectsize_ID <- 1:nrow(body.CV.final)

summary(body.CV.final)


################################################################################
# Loading phylogenetic information

# taxonomic information: taxa
load("data/phylogeny/taxa_Open_Tree_of_Life_20240909.RData")

# tree: tree_random
load("data/phylogeny/tree_random_20240909.Rdata")

# phylogenetic matrix: phylo_cor
load("data/phylogeny/phylo_cor_20240909.Rdata")


################################################################################
# Calculating our effect size of interest: lnCV
################################################################################

# calculating lnCV. Note that escalc() includes a small-size bias correction
body.CV.final <- as.data.frame(escalc(measure = "CVLN", 
                                      mi=mean, 
                                      sdi=SD, 
                                      ni=n,
                                      data=body.CV.final,
                                      add.measure=FALSE,
                                      append=TRUE))


# back-transforming lnCV to CV (coefficient of variation) to aid visualization
body.CV.final$CV <- exp(body.CV.final$yi)*100

# summary statistics for CV
round(summary(body.CV.final$CV),2)
round(sd(body.CV.final$CV),2)


# exploring male and female CV values
males.CV.perc <- body.CV.final[body.CV.final$sex=="male",
                               "CV"]
round(summary(males.CV.perc),2)
round(sd(males.CV.perc),2)
length(males.CV.perc)

females.CV.perc <- body.CV.final[body.CV.final$sex=="female",
                                 "CV"]
round(summary(females.CV.perc),2)
round(sd(females.CV.perc),2)
length(females.CV.perc)


################################################################################
# Visually exploring CV values
################################################################################

# ################################################################################
# # plotting male lnCV vs female lnCV
#
# # results not shown in the manuscript or its supplementary material
#
# # first, subsetting dataset
# males.lnCV.plot <- body.CV.final[body.CV.final$sex=="male",
#                                  c("pair_ID","yi")]
# females.lnCV.plot <- body.CV.final[body.CV.final$sex=="female",
#                                    c("pair_ID","yi")]
# 
# # merging males (yi.x) and females (yi.y)
# lnCV.plot <- merge(males.lnCV.plot,females.lnCV.plot,by="pair_ID",all=T)
# summary(lnCV.plot)
# 
# 
# ################################################################################
# # plotting lnCV wing length female ~ lnCV male with cleaned dataset
# par(mfrow = c(1, 1))
# 
# # using min of min values and max of max values
# axis.min <- floor(min(min(lnCV.plot$yi.x,na.rm=T),min(lnCV.plot$yi.y,na.rm=T)))
# axis.max <- ceiling(max(max(lnCV.plot$yi.x,na.rm=T),max(lnCV.plot$yi.y,na.rm=T)))
# 
# plot(lnCV.plot$yi.x,lnCV.plot$yi.y,
#      main = "lnCV(female)~lnCV(male)",
#      xlab = "lnCV(Wing length (Males))",
#      ylab = "lnCV(Wing length (Females))",
#      xlim = c(axis.min,axis.max), 
#      ylim = c(axis.min,axis.max))
# 
# abline(0,1)
# 
# # regression to add line to the plot
# male.female.lnCV.reg <- lm(lnCV.plot$yi.y~lnCV.plot$yi.x)
# abline(male.female.lnCV.reg$coefficients[1],male.female.lnCV.reg$coefficients[2],col = "red")
# 
# # and estimating the correlation
# cor.test(lnCV.plot$yi.y,lnCV.plot$yi.x)


################################################################################
# generating a density histogram to explore male and female CV distributions
# http://www.cookbook-r.com/Graphs/
# S2. Mean-Variance relationship and CV summary statistics
# Figure S3
ggplot(body.CV.final, 
       aes(CV, fill = sex)) + 
  geom_density(alpha = 0.4) +
  xlab("Wing length: Coefficient of Variation (CV %)") + 
  ylab("Density") +
  labs(fill = "Sex") +
  scale_x_continuous(breaks=seq(0, ceiling(max(body.CV.final$CV,rm.na=T)), 1)) +
  scale_y_continuous(breaks=seq(0, 0.75, 0.1)) +
  geom_vline(aes(xintercept=median(males.CV.perc)), 
             colour="#000099", linetype="dashed")+
  geom_vline(aes(xintercept=median(females.CV.perc)), 
             colour="#BB0000", linetype="dashed")+
  theme_bw()+
  theme(legend.justification=c(1,0), legend.position=c(0.95,0.65))

# S3. CV summary statistics
# males
summary(body.CV.final[body.CV.final$sex=="male" & 
                        !(is.na(body.CV.final$CV)),"CV"])
sd(body.CV.final[body.CV.final$sex=="male" & 
                   !(is.na(body.CV.final$CV)),"CV"])
length(body.CV.final[body.CV.final$sex=="male" & 
                       !(is.na(body.CV.final$CV)),"CV"])
length(unique(as.character(body.CV.final[body.CV.final$sex=="male" & 
                                           !(is.na(body.CV.final$CV)),
                                         "species.updated"])))
# females
summary(body.CV.final[body.CV.final$sex=="female" & 
                        !(is.na(body.CV.final$CV)),"CV"])
sd(body.CV.final[body.CV.final$sex=="female" & 
                   !(is.na(body.CV.final$CV)),"CV"])
length(body.CV.final[body.CV.final$sex=="female" & 
                       !(is.na(body.CV.final$CV)),"CV"])
length(unique(as.character(body.CV.final[body.CV.final$sex=="female" & 
                                           !(is.na(body.CV.final$CV)),
                                         "species.updated"])))

# ################################################################################
# # quick funnel plot exploration to better understand the data
# # precision
# plot(sqrt(1/body.CV.final$vi),exp(body.CV.final$yi))
# abline(exp(mean(body.CV.final$yi,na.rm=T)),0)
# abline(exp(median(body.CV.final$yi,na.rm=T)),0,col="red")
# 
# #se
# plot(sqrt(body.CV.final$vi),exp(body.CV.final$yi))
# abline(exp(mean(body.CV.final$yi,na.rm=T)),0)
# abline(exp(median(body.CV.final$yi,na.rm=T)),0,col="red")
# 
# #se
# plot(body.CV.final$vi,exp(body.CV.final$yi))
# abline(exp(mean(body.CV.final$yi,na.rm=T)),0)
# abline(exp(median(body.CV.final$yi,na.rm=T)),0,col="red")
# 
# #n original scale CV
# plot(body.CV.final$n,(body.CV.final$yi))
# abline((mean(body.CV.final$yi,na.rm=T)),0)
# abline((median(body.CV.final$yi,na.rm=T)),0,col="red")
# 
# #n
# plot(body.CV.final$n,exp(body.CV.final$yi))
# abline(exp(mean(body.CV.final$yi,na.rm=T)),0)
# abline(exp(median(body.CV.final$yi,na.rm=T)),0,col="red")
# 
# plot(body.CV.final$n,exp(body.CV.final$yi),xlim=c(0,100),ylim=c(0,0.16))

# there are a couple of suspiciously high values, but checking the original 
# papers did not clarify whether they are mistakes (SE vs SD), typos or just 
# real, therefore, we have decided to leave them in


# ################################################################################
# # Exploring how mean-scale variation (I = SD^2/mean^2) looks like 
# # More in: https://doi.org/10.1016/j.anbehav.2019.05.012 
# 
# # results not shown in the manuscript or its supplementary material
# 
# # calculating I
# body.CV.final$I <- (body.CV.final$SD^2/
#                       body.CV.final$mean^2)*100
# 
# summary(body.CV.final$I)
# 
# # plotting density histogram to explore male and female CV distributions
# ggplot(body.CV.final, 
#        aes(I, fill = sex)) + 
#   geom_density(alpha = 0.4) +
#   xlab("Wing length: I (%)") + 
#   ylab("Density") +
#   labs(fill = "Sex") +
#   scale_x_continuous(breaks=seq(0, 1, 0.1)) +
#   scale_y_continuous(breaks=seq(0, 16, 1)) +
#   geom_vline(aes(xintercept=median(body.CV.final[body.CV.final$sex=="male","I"])), 
#              colour="#000099", linetype="dashed")+
#   geom_vline(aes(xintercept=median(body.CV.final[body.CV.final$sex=="female","I"])), 
#              colour="#BB0000", linetype="dashed")+
#   theme_bw()+
#   theme(legend.justification=c(1,0), legend.position=c(0.95,0.65))



################################################################################
# Final dataset preparation before analyses
################################################################################

# setting reference levels for the factorial moderators
body.CV.final$migratory <- relevel(body.CV.final$migratory, 
                                   ref = "no")

body.CV.final$feeding.type <- relevel(body.CV.final$feeding.type, 
                                      ref = "no")

body.CV.final$migratory.pop.level <- relevel(body.CV.final$migratory.pop.level, 
                                             ref = "no")

body.CV.final$feeding.type.pop.level <- relevel(body.CV.final$feeding.type.pop.level, 
                                                ref = "no")

body.CV.final$migratory.inc.vagrants <- relevel(body.CV.final$migratory.inc.vagrants, 
                                                ref = "no")

body.CV.final$migratory.inc.vagrants.pop.level <- relevel(body.CV.final$migratory.inc.vagrants.pop.level, 
                                                          ref = "no")


# recoding factor levels to make them more self-explanatory
body.CV.final$migratory <- recode(body.CV.final$migratory, 
                                  yes = "fully migratory", 
                                  partially = "partially migratory",
                                  no = "non-migratory")

body.CV.final$feeding.type <- recode(body.CV.final$feeding.type, 
                                     yes = "fully aerial feeding",
                                     partially = "partially aerial feeding",
                                     no = "non-aerial feeding")


body.CV.final$migratory.pop.level <- recode(body.CV.final$migratory.pop.level, 
                                            yes = "fully migratory", 
                                            no = "non-migratory")

body.CV.final$feeding.type.pop.level <- recode(body.CV.final$feeding.type.pop.level, 
                                               yes = "fully aerial feeding",
                                               no = "non-aerial feeding")

body.CV.final$migratory.inc.vagrants <- recode(body.CV.final$migratory.inc.vagrants, 
                                               yes = "fully migratory", 
                                               partially = "partially migratory",
                                               no = "non-migratory")

body.CV.final$migratory.inc.vagrants.pop.level <- recode(body.CV.final$migratory.inc.vagrants.pop.level, 
                                                         yes = "fully migratory", 
                                                         no = "non-migratory")

summary(body.CV.final)

################################################################################
# Reordering species names in the same order as the phylogenetic tree

# First re-confirming that both species list agree
# species names in tree_random but not in body.CV.final
setdiff(tree_random$tip.label,
        unique(body.CV.final$species.updated))

# species names in body.CV.final but not in tree_random
setdiff(unique(body.CV.final$species.updated),
        tree_random$tip.label)

# then re-ordering
body.CV.final$species.updated <- factor(body.CV.final$species.updated,
                                        tree_random$tip.label) 

body.CV.final$species.updated.rep <- factor(body.CV.final$species.updated.rep,
                                            tree_random$tip.label)

# dummy coding sex so that the reference level is the average value (male-female)
body.CV.final$sex.num <- ifelse(body.CV.final$sex=="female",
                                -1, # female
                                1) # male

# dummy coding migratory.pop.level.num so that the reference level is the average value (yes-no)
body.CV.final$migratory.pop.level.num <- ifelse(body.CV.final$migratory.pop.level=="non-migratory",
                                                -1, # non-migratory
                                                1) # fully migratory

# dummy coding feeding.type.pop.level so that the reference level is the average value (yes-no)
body.CV.final$feeding.type.pop.level.num <- ifelse(body.CV.final$feeding.type.pop.level=="non-aerial feeding",
                                                   -1, # non-aerial feeding
                                                   1) # fully aerial feeding

# dummy coding migratory.pop.level.num so that the reference level is the average value (yes-no)
body.CV.final$migratory.inc.vagrants.pop.level.num <- ifelse(body.CV.final$migratory.inc.vagrants.pop.level=="non-migratory",
                                                             -1, # non-migratory
                                                             1) # fully migratory

summary(body.CV.final)
head(body.CV.final)


# # exporting the final dataset used for the analyses performed in this script
# # for the script use for sensitivity analyses (i.e., 003_sensitivity_analyses.R)
# write.csv(body.CV.final,
#           "data/final/05_final_full_and_clean_bird_wing_size_dataset_with_CV_values.csv",
#           row.names=FALSE)



################################################################################
# Variance-Covariance Matrices
################################################################################

# Creating a variance-covariance matrix at our level of interest to account for
# the fact that sampling errors are likely correlated at that level. Since we
# do not know the value of that potential correlation, we are creating three 
# different VCV matrices assuming a correlation of 0.25, 0.5 and 0.75. We will 
# use 0.5 (Noble et al. 2017, Mol Eco) as our correlation of interest, and 0.25 
# and 0.75 as sensitivity analyses for that 0.5 assumption

# We generated such VCV matrices for three levels: pair_ID, population_ID, and
# study_ID. We first tested pair_ID, since this one did not explain any variation, 
# we tested population_ID, and since that did not explain any variation either,
# we tested and retained the VCV matrix at the study_ID (AKA study ID) level for
# all our meta-analyses and meta-regressions. All code lines regarding pair_ID 
# and population_ID are commented and won't be run unless those code lines are
# uncommented

################################################################################
# pair_ID

VCV.0.25.pair_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                             cluster = body.CV.final$pair_ID, 
                                             r = 0.25)
VCV.0.50.pair_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                             cluster = body.CV.final$pair_ID, 
                                             r = 0.50)
VCV.0.75.pair_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                             cluster = body.CV.final$pair_ID, 
                                             r = 0.75)

################################################################################
# population_ID

VCV.0.25.population_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                                   cluster = body.CV.final$population_ID, 
                                                   r = 0.25)
VCV.0.50.population_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                                   cluster = body.CV.final$population_ID, 
                                                   r = 0.50)
VCV.0.75.population_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                                   cluster = body.CV.final$population_ID, 
                                                   r = 0.75)

################################################################################
# study_ID (AKA study_ID)

VCV.0.25.study_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                              cluster = body.CV.final$study_ID, 
                                              r = 0.25)
VCV.0.50.study_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                              cluster = body.CV.final$study_ID, 
                                              r = 0.50)
VCV.0.75.study_ID <- impute_covariance_matrix(vi = body.CV.final$vi, 
                                              cluster = body.CV.final$study_ID, 
                                              r = 0.75)


################################################################################
# Meta-analyses
################################################################################

################################################################################
# Intercept-only
# model_intercept_only <- rma.mv(yi = yi,
#                                V = vi,
#                                random = list(~ 1 | species.updated.rep,
#                                              ~ 1 | species.updated,
#                                              ~ 1 | study_ID,
#                                              ~ 1 | population_ID,
#                                              ~ 1 | pair_ID,
#                                              ~ 1 | effectsize_ID),
#                                R = list(species.updated = phylo_cor),
#                                data = body.CV.final,
#                                method = "REML",
#                                test = "t")
# 
# save(model_intercept_only,
#      file="models/sensitivity_analyses/model_intercept_only.RData")
load("models/sensitivity_analyses/model_intercept_only.RData")

# summary(model_intercept_only)
# predict(model_intercept_only,transf=exp)
# 
# 
# # I2, CV and M
# round(h.calc(model_intercept_only),3)
# 
# # total variance
# sum(model_intercept_only$sigma2)


################################################################################
# pair_ID
################################################################################


################################################################################
# intercept-only but with VCV 0.5 for pair_ID
# model_intercept_only_VCV050_pair_ID <- rma.mv(yi=yi,
#                                       V = VCV.0.50.pair_ID,
#                                       random = list(~ 1 | species.updated.rep,
#                                                     ~ 1 | species.updated,
#                                                     ~ 1 | study_ID,
#                                                     ~ 1 | population_ID,
#                                                     ~ 1 | pair_ID,
#                                                     ~ 1 | effectsize_ID),
#                                       R = list(species.updated = phylo_cor),
#                                       data=body.CV.final,
#                                       method="REML",
#                                       test="t")
# 
# save(model_intercept_only_VCV050_pair_ID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV050_pair_ID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV050_pair_ID.RData")

# summary(model_intercept_only_VCV050_pair_ID)
# predict(model_intercept_only_VCV050_pair_ID,transf=exp)


################################################################################
# intercept-only but with VCV 0.25 for pair_ID 
# model_intercept_only_VCV025_pair_ID <- rma.mv(yi=yi,
#                                       V = VCV.0.25.pair_ID,
#                                       random = list(~ 1 | species.updated.rep,
#                                                     ~ 1 | species.updated,
#                                                     ~ 1 | study_ID,
#                                                     ~ 1 | population_ID,
#                                                     ~ 1 | pair_ID,
#                                                     ~ 1 | effectsize_ID),
#                                       R = list(species.updated = phylo_cor),
#                                       data=body.CV.final,
#                                       method="REML",
#                                       test="t")
# 
# save(model_intercept_only_VCV025_pair_ID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV025_pair_ID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV025_pair_ID.RData")

# summary(model_intercept_only_VCV025_pair_ID)
# predict(model_intercept_only_VCV025_pair_ID, transf=exp)


################################################################################
# intercept-only but with VCV 0.75 for pair_ID
# model_intercept_only_VCV075_pair_ID <- rma.mv(yi=yi,
#                                       V = VCV.0.75.pair_ID,
#                                       random = list(~ 1 | species.updated.rep,
#                                                     ~ 1 | species.updated,
#                                                     ~ 1 | study_ID,
#                                                     ~ 1 | population_ID,
#                                                     ~ 1 | pair_ID,
#                                                     ~ 1 | effectsize_ID),
#                                       R = list(species.updated = phylo_cor),
#                                       data=body.CV.final,
#                                       method="REML",
#                                       test="t")
# 
# save(model_intercept_only_VCV075_pair_ID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV075_pair_ID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV075_pair_ID.RData")

# summary(model_intercept_only_VCV075_pair_ID)
# predict(model_intercept_only_VCV075_pair_ID, transf=exp)


################################################################################
# population_ID
################################################################################


################################################################################
# intercept-only but with VCV 0.5 for population_ID
# model_intercept_only_VCV050_population_ID <- rma.mv(yi=yi,
#                                             V = VCV.0.50.population_ID,
#                                             random = list(~ 1 | species.updated.rep,
#                                                           ~ 1 | species.updated,
#                                                           ~ 1 | study_ID,
#                                                           ~ 1 | population_ID,
#                                                           ~ 1 | pair_ID,
#                                                           ~ 1 | effectsize_ID),
#                                             R = list(species.updated = phylo_cor),
#                                             data=body.CV.final,
#                                             method="REML",
#                                             test="t")
# 
# save(model_intercept_only_VCV050_population_ID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV050_population_ID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV050_population_ID.RData")

# summary(model_intercept_only_VCV050_population_ID)
# predict(model_intercept_only_VCV050_population_ID, transf=exp)


################################################################################
# intercept-only but with VCV 0.25 for population_ID
# model_intercept_only_VCV025_population_ID <- rma.mv(yi=yi,
#                                             V = VCV.0.25.population_ID,
#                                             random = list(~ 1 | species.updated.rep,
#                                                           ~ 1 | species.updated,
#                                                           ~ 1 | study_ID,
#                                                           ~ 1 | population_ID,
#                                                           ~ 1 | pair_ID,
#                                                           ~ 1 | effectsize_ID),
#                                             R = list(species.updated = phylo_cor),
#                                             data=body.CV.final,
#                                             method="REML",
#                                             test="t")
# 
# save(model_intercept_only_VCV025_population_ID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV025_population_ID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV025_population_ID.RData")

# summary(model_intercept_only_VCV025_population_ID)
# predict(model_intercept_only_VCV025_population_ID, transf=exp)


################################################################################
# intercept-only but with VCV 0.75 for population_ID
# model_intercept_only_VCV075_population_ID <- rma.mv(yi=yi,
#                                             V = VCV.0.75.population_ID,
#                                             random = list(~ 1 | species.updated.rep,
#                                                           ~ 1 | species.updated,
#                                                           ~ 1 | study_ID,
#                                                           ~ 1 | population_ID,
#                                                           ~ 1 | pair_ID,
#                                                           ~ 1 | effectsize_ID),
#                                             R = list(species.updated = phylo_cor),
#                                             data=body.CV.final,
#                                             method="REML",
#                                             test="t")
# 
# save(model_intercept_only_VCV075_population_ID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV075_population_ID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV075_population_ID.RData")

# summary(model_intercept_only_VCV075_population_ID)
# predict(model_intercept_only_VCV075_population_ID, transf=exp)


################################################################################
# study_ID
################################################################################


################################################################################
# # intercept-only but with VCV 0.5 for study_ID
################################################################################

# THIS IS OUR MODEL OF CHOICE, AND THUS, THE ONE PRESENTED IN THE MANUSCRIPT!!!

# model_intercept_only_VCV050_studyID <- rma.mv(yi = yi,
#                                               V = VCV.0.50.study_ID,
#                                               random = list(~ 1 | species.updated.rep,
#                                                             ~ 1 | species.updated,
#                                                             ~ 1 | study_ID,
#                                                             ~ 1 | population_ID,
#                                                             ~ 1 | pair_ID,
#                                                             ~ 1 | effectsize_ID),
#                                               R = list(species.updated = phylo_cor),
#                                               data = body.CV.final,
#                                               method = "REML",
#                                               test = "t")
# 
# save(model_intercept_only_VCV050_studyID,
#      file="models/model_intercept_only_VCV050_studyID.RData")
load("models/model_intercept_only_VCV050_studyID.RData")

summary(model_intercept_only_VCV050_studyID)
predict(model_intercept_only_VCV050_studyID, transf=exp)

################################################################################
# # intercept-only but with VCV 0.5 for study_ID: using raw lnCV
# that is, no correction for small sample size to the lnCV value (but keeping
# it for its sampling variance)
################################################################################

# body.CV.final$raw.lnCV <- log(body.CV.final$SD) - log(body.CV.final$mean)
# 
# model_intercept_only_VCV050_studyID_rawlnCV <- rma.mv(yi = raw.lnCV,
#                                                       V = VCV.0.50.study_ID,
#                                                       random = list(~ 1 | species.updated.rep,
#                                                                     ~ 1 | species.updated,
#                                                                     ~ 1 | study_ID,
#                                                                     ~ 1 | population_ID,
#                                                                     ~ 1 | pair_ID,
#                                                                     ~ 1 | effectsize_ID),
#                                                       R = list(species.updated = phylo_cor),
#                                                       data = body.CV.final,
#                                                       method = "REML",
#                                                       test = "t")
# 
# save(model_intercept_only_VCV050_studyID_rawlnCV,
#      file="models/sensitivity_analyses/model_intercept_only_VCV050_studyID_rawlnCV.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV050_studyID_rawlnCV.RData")

# summary(model_intercept_only_VCV050_studyID_rawlnCV)
# predict(model_intercept_only_VCV050_studyID_rawlnCV, transf=exp)


################################################################################
# # intercept-only but with VCV 0.5 for study_ID: accounting for sample size
################################################################################
# 
# # median centered
# body.CV.final$n.c <- body.CV.final$n - median(body.CV.final$n)
# 
# model_intercept_only_VCV050_studyID_n <- rma.mv(yi = yi,
#                                                 V = VCV.0.50.study_ID,
#                                                 mods = 1 + n.c,
#                                                 random = list(~ 1 | species.updated.rep,
#                                                               ~ 1 | species.updated,
#                                                               ~ 1 | study_ID,
#                                                               ~ 1 | population_ID,
#                                                               ~ 1 | pair_ID,
#                                                               ~ 1 | effectsize_ID),
#                                                 R = list(species.updated = phylo_cor),
#                                                 data = body.CV.final,
#                                                 method = "REML",
#                                                 test = "t")
# 
# save(model_intercept_only_VCV050_studyID_n,
#      file="models/sensitivity_analyses/model_intercept_only_VCV050_studyID_n.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV050_studyID_n.RData")

# summary(model_intercept_only_VCV050_studyID_n)
# round(exp(model_intercept_only_VCV050_studyID_n$beta)*100,2)
# round(exp(model_intercept_only_VCV050_studyID_n$ci.lb)*100,2)
# round(exp(model_intercept_only_VCV050_studyID_n$ci.ub)*100,2)


################################################################################
# # intercept-only but with VCV 0.5 for study_ID: accounting for mean
################################################################################

# median centered
body.CV.final$mean.c <- body.CV.final$mean - median(body.CV.final$mean)
# body.CV.final$mean.c <- log(body.CV.final$mean) - median(log(body.CV.final$mean))

# model_intercept_only_VCV050_studyID_mean <- rma.mv(yi = yi,
#                                                    V = VCV.0.50.study_ID,
#                                                    mods = 1 + mean.c,
#                                                    random = list(~ 1 | species.updated.rep,
#                                                                  ~ 1 | species.updated,
#                                                                  ~ 1 | study_ID,
#                                                                  ~ 1 | population_ID,
#                                                                  ~ 1 | pair_ID,
#                                                                  ~ 1 | effectsize_ID),
#                                                    R = list(species.updated = phylo_cor),
#                                                    data = body.CV.final,
#                                                    method = "REML",
#                                                    test = "t")
# 
# save(model_intercept_only_VCV050_studyID_mean,
#      file="models/sensitivity_analyses/model_intercept_only_VCV050_studyID_mean.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV050_studyID_mean.RData")
# save(model_intercept_only_VCV050_studyID_mean,
#     file="models/sensitivity_analyses/model_intercept_only_VCV050_studyID_lnmean.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV050_studyID_lnmean.RData")

# summary(model_intercept_only_VCV050_studyID_mean)
# round(exp(model_intercept_only_VCV050_studyID_mean$beta)*100,2)
# round(exp(model_intercept_only_VCV050_studyID_mean$ci.lb)*100,2)
# round(exp(model_intercept_only_VCV050_studyID_mean$ci.ub)*100,2)


################################################################################
# intercept-only but with VCV 0.25 for study_ID
# model_intercept_only_VCV025_studyID <- rma.mv(yi=yi,
#                                               V = VCV.0.25.study_ID,
#                                               random = list(~ 1 | species.updated.rep,
#                                                             ~ 1 | species.updated,
#                                                             ~ 1 | study_ID,
#                                                             ~ 1 | population_ID,
#                                                             ~ 1 | pair_ID,
#                                                             ~ 1 | effectsize_ID),
#                                               R = list(species.updated = phylo_cor),
#                                               data=body.CV.final,
#                                               method="REML",
#                                               test="t")
# 
# save(model_intercept_only_VCV025_studyID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV025_studyID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV025_studyID.RData")

# summary(model_intercept_only_VCV025_studyID)
# predict(model_intercept_only_VCV025_studyID, transf=exp)


################################################################################
# intercept-only but with VCV 0.75 for study_ID
# model_intercept_only_VCV075_studyID <- rma.mv(yi=yi,
#                                               V = VCV.0.75.study_ID,
#                                               random = list(~ 1 | species.updated.rep,
#                                                             ~ 1 | species.updated,
#                                                             ~ 1 | study_ID,
#                                                             ~ 1 | population_ID,
#                                                             ~ 1 | pair_ID,
#                                                             ~ 1 | effectsize_ID),
#                                               R = list(species.updated = phylo_cor),
#                                               data=body.CV.final,
#                                               method="REML",
#                                               test="t")
# 
# save(model_intercept_only_VCV075_studyID,
#      file="models/sensitivity_analyses/model_intercept_only_VCV075_studyID.RData")
load("models/sensitivity_analyses/model_intercept_only_VCV075_studyID.RData")

# summary(model_intercept_only_VCV075_studyID)
# predict(model_intercept_only_VCV075_studyID, transf=exp)


################################################################################
# visualizing all results before choosing the desired model as main analysis
################################################################################

# no VCV
predict(model_intercept_only, transf=exp)

# VCV 0.5
predict(model_intercept_only_VCV050_pair_ID, transf=exp)
predict(model_intercept_only_VCV050_population_ID, transf=exp)
predict(model_intercept_only_VCV050_studyID, transf=exp) # OUR MODEL!

# VCV 0.25
predict(model_intercept_only_VCV025_pair_ID, transf=exp)
predict(model_intercept_only_VCV025_population_ID, transf=exp)
predict(model_intercept_only_VCV025_studyID, transf=exp)

# VCV 0.75
predict(model_intercept_only_VCV075_pair_ID, transf=exp)
predict(model_intercept_only_VCV075_population_ID, transf=exp)
predict(model_intercept_only_VCV075_studyID, transf=exp)


# No matter what level of correlation between sampling variances (0.25, 0.5, 
# 0.75) we model or whether we do the grouping based on pair_ID, population_ID 
# or study_ID, our results at the mean level essentially stay unchanged 
# and the 95% CI and 95% PI change very little. For the main models, we have
# decided to use a VCV of 0.5 correlation based on study_ID, which seems to be
# the second most conservative (wider intervals) approach after the same model
# but using a VCV of 0.75 correlation.


################################################################################
# Exploring likelihood profiles random effects for our model of choice
################################################################################

# This takes quite some time. Results copied below. Things look good.
# profile(model_intercept_only_VCV050_studyID)

# Figures saved for the future, time elapsed added here below. Long, long time
# Profiling sigma2 = 1 
# |==================================================| 100% elapsed=35m 04s
# Profiling sigma2 = 2 
# |==================================================| 100% elapsed=26m 51s
# Profiling sigma2 = 3 
# |==================================================| 100% elapsed=32m 12s
# Profiling sigma2 = 4 
# |==================================================| 100% elapsed=29m 54s
# Profiling sigma2 = 5 
# |==================================================| 100% elapsed=30m 10s
# Profiling sigma2 = 6 
# |==================================================| 100% elapsed=29m 27s



################################################################################
# HETEROGENEITY: exploring heterogeneity in detail
################################################################################

# calculating total variance or total absolute heterogeneity
round(sum(model_intercept_only_VCV050_studyID$sigma2),4)


# Calculating typical sampling variance, which captures the statistical noise of 
# the data, but is rarely reported
round(sigma2_v(model_intercept_only_VCV050_studyID),3)


# # I2, CV and M (Yang et al. 2024)
# round(h.calc(model_intercept_only_VCV050_studyID),3)

# using orchaRd to calculate I2, CV and M (Yang et al. 2024)
round(i2_ml(model_intercept_only_VCV050_studyID),1)
round(cvh2_ml(model_intercept_only_VCV050_studyID),3)
round(m2_ml(model_intercept_only_VCV050_studyID),3)

# Notes on interpretation of I2, CV and M

# I2 = 94.2% that's between 50th and 75th percentile of empirically derived ones
# that also means that heterogeneity is 94.2/5.8 = 16.24138 times larger than that 
# of statistical noise

# CV total = 0.005. This can be interpreted as heterogeneity being...

# M total = 0.005 is way smaller than CV due to the very small meta-analytic 
# mean


# M combines the strengths of variance-scaled (I2) and mean-scaled metrics (CVH) 
# and has been suggested as a remedy for the problems of both I2 and CVH in 
# scenarios such as those observed in our dataset. Thus, together with total 
# variance (𝜎2), we consider M to better reflect heterogeneity in our dataset. 
# For equations and more information about the interpretation of these 
# heterogeneity metrics, see Yang et al. (2024)


################################################################################
# Visualizing heterogeneity
################################################################################

# make dataframe for plotting
h_status <- h.calc2(model_intercept_only_VCV050_studyID)

# adding sigmas
h_status$sigma2s <- c(sum(model_intercept_only_VCV050_studyID$sigma2),
                      model_intercept_only_VCV050_studyID$sigma2[1],
                      model_intercept_only_VCV050_studyID$sigma2[2],
                      model_intercept_only_VCV050_studyID$sigma2[3],
                      model_intercept_only_VCV050_studyID$sigma2[4],
                      model_intercept_only_VCV050_studyID$sigma2[5],
                      model_intercept_only_VCV050_studyID$sigma2[6])

# rounding values
round(h_status$I2s_Shinichi,1)
round(h_status$CVHs,3)
round(h_status$Ms,3)
round(h_status$sigma2s,3)


#h_status$CVs <- h_status$CVs*100
h_status$levels <- rownames(h_status)  

# recoding random effect levels to make them more self-explanatory
h_status$levels <- dplyr::recode(h_status$levels, 
                                 "Total" = "Total",  
                                 "species.updated.rep" = "Species",  
                                 "species.updated" = "Phylogeny", 
                                 "study_ID" = "Between-study", 
                                 "population_ID" = "Population",
                                 "pair_ID" = "Paired estimates",
                                 "effectsize_ID" = "Within-study")

h_status$levels <- as.factor(h_status$levels)
h_status$levels <- factor(h_status$levels, levels = c("Total",
                                                      "Between-study",
                                                      "Paired estimates",
                                                      "Population",
                                                      "Phylogeny", 
                                                      "Species", 
                                                      "Within-study"))


# plotting time
p.sigma <- ggplot(h_status, aes(levels, sigma2s)) +
  geom_col(alpha = 1,
           color = wes_palette('GrandBudapest1', 4, type = 'discrete')[1],
           fill = wes_palette('GrandBudapest1', 4, type = 'discrete')[1]) +
  labs(y = expression("Variance"), x = "" ,
       title = "Unstandardised heterogeneity") +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001)) + # https://stackoverflow.com/questions/38722202/how-do-i-change-the-number-of-decimal-places-on-axis-labels-in-ggplot2
  theme_bw() +
  theme(legend.background = element_blank(),
        axis.text = element_text(size = 12, color = "black"),
        axis.title = element_text(size = 12, color = "black")
  )

# I2
p.I2 <- ggplot(h_status, aes(levels, I2s_Shinichi/100)) +
  geom_col(alpha = 1, color = wes_palette('GrandBudapest1', 4, 
                                          type = 'discrete')[2], 
           fill = wes_palette('GrandBudapest1', 4, type = 'discrete')[2]) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y = expression(paste(italic(I)[]^2)), x = "" , 
       title = "Source of heterogeneity") + 
  theme_bw() +
  theme(legend.background = element_blank(),
        axis.text = element_text(size = 12, color = "black"),
        axis.title = element_text(size = 12, color = "black")
  ) 

# CV
p.CV <- ggplot(h_status, aes(levels, CVHs)) +
  geom_col(alpha = 1, color = wes_palette('GrandBudapest1', 4, 
                                          type = 'discrete')[3], 
           fill = wes_palette('GrandBudapest1', 4, type = 'discrete')[3]) +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001)) +
  
  labs(y = expression(paste(italic(CVH2)[])), x = "" , 
       title = "Magnitude of heterogeneity") + 
  theme_bw() +
  theme(legend.background = element_blank(),
        axis.text = element_text(size = 12, color = "black"),
        axis.title = element_text(size = 12, color = "black")
  )   


# M
p.M <- ggplot(h_status, aes(x = levels, y = Ms)) +
  geom_col(alpha = 1, color = wes_palette('GrandBudapest1', 4, 
                                          type = 'discrete')[4], 
           fill = wes_palette('GrandBudapest1', 4, type = 'discrete')[4]) +
  labs(y = expression(paste(italic(M2)[])), x = "" , 
       title = "Magnitude of heterogeneity") + 
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001)) + # https://stackoverflow.com/questions/38722202/how-do-i-change-the-number-of-decimal-places-on-axis-labels-in-ggplot2
  theme_bw() +
  theme(legend.background = element_blank(),
        axis.text = element_text(size = 12, color = "black"),
        axis.title = element_text(size = 12, color = "black")
  )  

# info here: https://patchwork.data-imaginist.com/articles/guides/layout.html

# saving the figure
png(filename = 'figures/supplementary_figures/Figure_S4_Heterogeneity_pluralistic_approach.png', 
    width = 19, height = 19, units = 'cm', 
    res = 600)

#png(filename = "all.png", width = 9, height = 8, units = "in", type = "windows", res = 400)
p.sigma + p.I2 + p.CV + p.M + 
  plot_layout(ncol = 2, nrow = 2,
              axes = "collect") + 
  plot_annotation(tag_levels = "A") & 
  theme(plot.tag = element_text(face = "bold"),
        axis.text.x = element_text(angle=45, vjust=1.0, hjust=1))

dev.off()


################################################################################
# Meta-regressions
################################################################################

################################################################################
# SEX DIFFERENCES?
################################################################################

################################################################################
# Testing if the previously found sex effect, where females have been found to 
# have larger CV than males in several body size traits, remains in our dataset

# Previous tests:
# Reinhold & Engqvist 2013: https://doi.org/10.1111/evo.12224 (although multiple traits included not only wing size)
# Nakagawa et al. 2015: https://doi.org/10.1111/2041-210X.12309 (although multiple traits included not only wing size)

# metaregression_unimoderator_sex <- rma.mv(yi = yi,
#                                           V = VCV.0.50.study_ID,
#                                           mod = ~ 1 + sex,
#                                           random = list(~ 1 | species.updated.rep,
#                                                         ~ 1 | species.updated,
#                                                         ~ 1 | study_ID,
#                                                         ~ 1 | population_ID,
#                                                         ~ 1 | pair_ID,
#                                                         ~ 1 | effectsize_ID),
#                                           R = list(species.updated = phylo_cor),
#                                           data=body.CV.final,
#                                           method="REML",
#                                           test="t")
# 
# save(metaregression_unimoderator_sex,
#      file="models/metaregression_unimoderator_sex.RData")
load("models/metaregression_unimoderator_sex.RData")

summary(metaregression_unimoderator_sex)

# getting marginal R2
round(r2_ml(metaregression_unimoderator_sex)*100,2)


# the equivalent model but without intercept 
# metaregression_unimoderator_sex.nointercept <- rma.mv(yi = yi,
#                                                       V = VCV.0.50.study_ID,
#                                                       mod = ~ -1 + sex,
#                                                       random = list(~ 1 | species.updated.rep,
#                                                                     ~ 1 | species.updated,
#                                                                     ~ 1 | study_ID,
#                                                                     ~ 1 | population_ID,
#                                                                     ~ 1 | pair_ID,
#                                                                     ~ 1 | effectsize_ID),
#                                                       R = list(species.updated = phylo_cor),
#                                                       data=body.CV.final,
#                                                       method="REML",
#                                                       test="t")
# 
# save(metaregression_unimoderator_sex.nointercept,
#      file="models/metaregression_unimoderator_sex_nointercept.RData")
load("models/metaregression_unimoderator_sex_nointercept.RData")

summary(metaregression_unimoderator_sex.nointercept)
round(exp(metaregression_unimoderator_sex.nointercept$beta)*100,2)
round(exp(metaregression_unimoderator_sex.nointercept$ci.lb)*100,2)
round(exp(metaregression_unimoderator_sex.nointercept$ci.ub)*100,2)

# summary(body.CV.final$yi)
# exp(min(body.CV.final$yi))*100
# exp(max(body.CV.final$yi))*100
# summary(attributes(body.CV.final$yi)$ni)


################################################################################
# plotting results

orchard.plot.sex <- orchaRd::orchard_plot(metaregression_unimoderator_sex,
                                          mod = "sex",
                                          group = "species.updated.rep",
                                          xlab = "Effect size (CV %)",
                                          trunk.size = 1.55,
                                          branch.size = 3.5,
                                          twig.size = 1.25,
                                          k.pos = c(4.5,4),
                                          transfm  = "percent",
                                          colour = F)

# # saving the figure
# png(filename = 'figures/Figure_3_Sex_Chromosome_Hypothesis.png',
#     width = 21, height = 10, units = 'cm',
#     res = 600)
# 
# # cropped
# orchard.plot.sex +
#   scale_y_continuous(limits = c(1,6),
#                      breaks = seq(1,6,0.5)) +
#   theme(axis.text.y = element_text(size = 14),
#         axis.title = element_text(size = 16))
# 
# dev.off()

# saving the figure
png(filename = 'figures/supplementary_figures/Figure_S5_Sex_Chromosome_Hypothesis.png',
    width = 21, height = 10, units = 'cm',
    res = 600)

# supplementary material
orchard.plot.sex +
  scale_y_continuous(limits = c(0,14),
                     breaks = seq(0,14,1))

dev.off()

################################################################################
# FEEDING TYPE: species-specific
################################################################################

# metaregression_unimoderator_feeding_type <- rma.mv(yi = yi,
#                                                    V = VCV.0.50.study_ID,
#                                                    mod = ~ 1 +
#                                                      feeding.type,
#                                                    random = list(~ 1 | species.updated.rep,
#                                                                  ~ 1 | species.updated,
#                                                                  ~ 1 | study_ID,
#                                                                  ~ 1 | population_ID,
#                                                                  ~ 1 | pair_ID,
#                                                                  ~ 1 | effectsize_ID),
#                                                    R = list(species.updated = phylo_cor),
#                                                    data=body.CV.final,
#                                                    method="REML",
#                                                    test="t")
# 
# save(metaregression_unimoderator_feeding_type,
#      file="models/metaregression_unimoderator_feeding_type.RData")
load("models/metaregression_unimoderator_feeding_type.RData")


summary(metaregression_unimoderator_feeding_type,3)
# though it is clear from the estimates, here is the actual statistical test 
# between partially and fully migratory (no reported for simplicity)
car::linearHypothesis(metaregression_unimoderator_feeding_type, rbind(c(0,1,-1)))

# getting marginal R2
round(r2_ml(metaregression_unimoderator_feeding_type)*100,2)


# the equivalent model but without intercept
# metaregression_unimoderator_feeding_type.nointercept <- rma.mv(yi = yi,
#                                                                V = VCV.0.50.study_ID,
#                                                                mod = ~ -1 +
#                                                                  feeding.type,
#                                                                random = list(~ 1 | species.updated.rep,
#                                                                              ~ 1 | species.updated,
#                                                                              ~ 1 | study_ID,
#                                                                              ~ 1 | population_ID,
#                                                                              ~ 1 | pair_ID,
#                                                                              ~ 1 | effectsize_ID),
#                                                                R = list(species.updated = phylo_cor),
#                                                                data=body.CV.final,
#                                                                method="REML",
#                                                                test="t")
# 
# save(metaregression_unimoderator_feeding_type.nointercept,
#      file="models/metaregression_unimoderator_feeding_type_nointercept.RData")
load("models/metaregression_unimoderator_feeding_type_nointercept.RData")

summary(metaregression_unimoderator_feeding_type.nointercept,3)
round(exp(metaregression_unimoderator_feeding_type.nointercept$beta)*100,2)
round(exp(metaregression_unimoderator_feeding_type.nointercept$ci.lb)*100,2)
round(exp(metaregression_unimoderator_feeding_type.nointercept$ci.ub)*100,2)


################################################################################
# plotting results

orchard.plot.feeding.type <- orchaRd::orchard_plot(metaregression_unimoderator_feeding_type, 
                                                   mod = "feeding.type", 
                                                   group = "species.updated.rep", 
                                                   xlab = "Effect size (CV %)",
                                                   trunk.size = 1.85,
                                                   branch.size = 3.5,
                                                   twig.size = 1.25,
                                                   k.pos = c(4.5,4),
                                                   transfm  = "percent",
                                                   colour = F)

# main text: cropped
orchard.plot.feeding.type.cropped <- orchard.plot.feeding.type +
  scale_colour_manual(values = c("grey50","grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(1,6),
                     breaks = seq(1,6,0.5))

orchard.plot.feeding.type.cropped

# saving the figure
png(filename = 'figures/supplementary_figures/Figure_S6_Feeding_species_level.png', 
    width = 21, height = 10, units = 'cm', 
    res = 600)

# supplementary material
orchard.plot.feeding.type + 
  scale_colour_manual(values = c("grey50","grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(0,14),
                     breaks = seq(0,14,1)) +
  theme(axis.text.y = element_text(size = 7.5))

dev.off()

################################################################################
# MIGRATORY: species-specific
################################################################################

# metaregression_unimoderator_migratory <- rma.mv(yi = yi,
#                                                 V = VCV.0.50.study_ID,
#                                                 mod = ~ 1 +
#                                                   migratory,
#                                                 random = list(~ 1 | species.updated.rep,
#                                                               ~ 1 | species.updated,
#                                                               ~ 1 | study_ID,
#                                                               ~ 1 | population_ID,
#                                                               ~ 1 | pair_ID,
#                                                               ~ 1 | effectsize_ID),
#                                                 R = list(species.updated = phylo_cor),
#                                                 data=body.CV.final,
#                                                 method="REML",
#                                                 test="t")
# 
# save(metaregression_unimoderator_migratory,
#      file="models/metaregression_unimoderator_migratory.RData")
load("models/metaregression_unimoderator_migratory.RData")


summary(metaregression_unimoderator_migratory,3)
# though it is clear from the estimates, here is the actual statistical test 
# between partially and fully migratory (no reported for simplicity)
car::linearHypothesis(metaregression_unimoderator_migratory, rbind(c(0,1,-1)))

# getting marginal R2
round(r2_ml(metaregression_unimoderator_migratory)*100,2)


# the equivalent model but without intercept 
# metaregression_unimoderator_migratory.nointercept <- rma.mv(yi = yi,
#                                                             V = VCV.0.50.study_ID,
#                                                             mod = ~ -1 +
#                                                               migratory,
#                                                             random = list(~ 1 | species.updated.rep,
#                                                                           ~ 1 | species.updated,
#                                                                           ~ 1 | study_ID,
#                                                                           ~ 1 | population_ID,
#                                                                           ~ 1 | pair_ID,
#                                                                           ~ 1 | effectsize_ID),
#                                                             R = list(species.updated = phylo_cor),
#                                                             data=body.CV.final,
#                                                             method="REML",
#                                                             test="t")
# 
# save(metaregression_unimoderator_migratory.nointercept,
#      file="models/metaregression_unimoderator_migratory_nointercept.RData")
load("models/metaregression_unimoderator_migratory_nointercept.RData")

# getting marginal R2
round(r2_ml(metaregression_unimoderator_migratory.nointercept)*100,2)

summary(metaregression_unimoderator_migratory.nointercept,3)
round(exp(metaregression_unimoderator_migratory.nointercept$beta)*100,2)
round(exp(metaregression_unimoderator_migratory.nointercept$ci.lb)*100,2)
round(exp(metaregression_unimoderator_migratory.nointercept$ci.ub)*100,2)


################################################################################
# plotting results

orchard.plot.migratory <- orchaRd::orchard_plot(metaregression_unimoderator_migratory, 
                                                mod = "migratory", 
                                                group = "species.updated.rep", 
                                                xlab = "Effect size (CV %)",
                                                trunk.size = 1.85,
                                                branch.size = 3.5,
                                                twig.size = 1.25,
                                                k.pos = c(4.5,4),
                                                transfm  = "percent",
                                                colour = F)
# main text: cropped
orchard.plot.migratory.cropped <- orchard.plot.migratory + 
  scale_colour_manual(values = c("grey50","grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(1,6),
                     breaks = seq(1,6,0.5))

# saving the figure
png(filename = 'figures/supplementary_figures/Figure_S7_Migratory_species_level.png', 
    width = 21, height = 10, units = 'cm', 
    res = 600)

# supplementary material
orchard.plot.migratory + 
  scale_colour_manual(values = c("grey50","grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(0,14),
                     breaks = seq(0,14,1)) +
  theme(axis.text.y = element_text(size = 7.5))

dev.off()

################################################################################
# FEEDING AND MIGRATORY: species-specific
# S4. Calculating total heterogeneity explained
################################################################################

# metaregression_feeding_and_migratory <- rma.mv(yi = yi,
#                                                V = VCV.0.50.study_ID,
#                                                mod = ~ 1 +
#                                                  migratory +
#                                                  feeding.type,
#                                                random = list(~ 1 | species.updated.rep,
#                                                              ~ 1 | species.updated,
#                                                              ~ 1 | study_ID,
#                                                              ~ 1 | population_ID,
#                                                              ~ 1 | pair_ID,
#                                                              ~ 1 | effectsize_ID),
#                                                R = list(species.updated = phylo_cor),
#                                                data=body.CV.final,
#                                                method="REML",
#                                                test="t")
# 
# save(metaregression_feeding_and_migratory,
#      file="models/metaregression_feeding_and_migratory.RData")
load("models/metaregression_feeding_and_migratory.RData")


summary(metaregression_feeding_and_migratory,3)
round(r2_ml(metaregression_feeding_and_migratory)*100,2)


################################################################################
# FEEDING TYPE: population-specific
################################################################################

# metaregression_unimoderator_feeding_type_pop_level <- rma.mv(yi = yi,
#                                                              V = VCV.0.50.study_ID,
#                                                              mod = ~ 1 +
#                                                                feeding.type.pop.level,
#                                                              random = list(~ 1 | species.updated.rep,
#                                                                            ~ 1 | species.updated,
#                                                                            ~ 1 | study_ID,
#                                                                            ~ 1 | population_ID,
#                                                                            ~ 1 | pair_ID,
#                                                                            ~ 1 | effectsize_ID),
#                                                              R = list(species.updated = phylo_cor),
#                                                              data=body.CV.final,
#                                                              method="REML",
#                                                              test="t")
# 
# save(metaregression_unimoderator_feeding_type_pop_level,
#      file="models/metaregression_unimoderator_feeding_type_pop_level.RData")
load("models/metaregression_unimoderator_feeding_type_pop_level.RData")


summary(metaregression_unimoderator_feeding_type_pop_level,3)

# getting marginal R2
round(r2_ml(metaregression_unimoderator_feeding_type_pop_level)*100,2)


# the equivalent model but without intercept
# metaregression_unimoderator_feeding_type_pop_level.nointercept <- rma.mv(yi = yi,
#                                                                          V = VCV.0.50.study_ID,
#                                                                          mod = ~ -1 +
#                                                                            feeding.type.pop.level,
#                                                                          random = list(~ 1 | species.updated.rep,
#                                                                                        ~ 1 | species.updated,
#                                                                                        ~ 1 | study_ID,
#                                                                                        ~ 1 | population_ID,
#                                                                                        ~ 1 | pair_ID,
#                                                                                        ~ 1 | effectsize_ID),
#                                                                          R = list(species.updated = phylo_cor),
#                                                                          data=body.CV.final,
#                                                                          method="REML",
#                                                                          test="t")
# 
# save(metaregression_unimoderator_feeding_type_pop_level.nointercept,
#      file="models/metaregression_unimoderator_feeding_type_pop_level_nointercept.RData")
load("models/metaregression_unimoderator_feeding_type_pop_level_nointercept.RData")

summary(metaregression_unimoderator_feeding_type_pop_level.nointercept,3)
round(exp(metaregression_unimoderator_feeding_type_pop_level.nointercept$beta)*100,2)
round(exp(metaregression_unimoderator_feeding_type_pop_level.nointercept$ci.lb)*100,2)
round(exp(metaregression_unimoderator_feeding_type_pop_level.nointercept$ci.ub)*100,2)


################################################################################
# plotting results

orchard.plot.feeding.type.pop.level <- orchaRd::orchard_plot(metaregression_unimoderator_feeding_type_pop_level, 
                                                             mod = "feeding.type.pop.level", 
                                                             group = "species.updated.rep", 
                                                             xlab = "Effect size (CV %)",
                                                             trunk.size = 1.85,
                                                             branch.size = 3.5,
                                                             twig.size = 1.25,
                                                             k.pos = c(4.5,4),
                                                             transfm  = "percent",
                                                             colour = F)
# main text: cropped
orchard.plot.feeding.type.pop.level.cropped <- orchard.plot.feeding.type.pop.level + 
  scale_colour_manual(values = c("grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(1,6),
                     breaks = seq(1,6,0.5))

# saving the figure
png(filename = 'figures/supplementary_figures/Figure_S8_Feeding_population_level.png', 
    width = 21, height = 10, units = 'cm', 
    res = 600)

# supplementary material
orchard.plot.feeding.type.pop.level + 
  scale_colour_manual(values = c("grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(0,14),
                     breaks = seq(0,14,1))

dev.off()

################################################################################
# MIGRATORY: population-specific
################################################################################

# metaregression_unimoderator_migratory_pop_level <- rma.mv(yi = yi,
#                                                           V = VCV.0.50.study_ID,
#                                                           mod = ~ 1 +
#                                                             migratory.pop.level,
#                                                           random = list(~ 1 | species.updated.rep,
#                                                                         ~ 1 | species.updated,
#                                                                         ~ 1 | study_ID,
#                                                                         ~ 1 | population_ID,
#                                                                         ~ 1 | pair_ID,
#                                                                         ~ 1 | effectsize_ID),
#                                                           R = list(species.updated = phylo_cor),
#                                                           data=body.CV.final,
#                                                           method="REML",
#                                                           test="t")
# 
# save(metaregression_unimoderator_migratory_pop_level,
#      file="models/metaregression_unimoderator_migratory_pop_level.RData")
load("models/metaregression_unimoderator_migratory_pop_level.RData")


summary(metaregression_unimoderator_migratory_pop_level,3)

# getting marginal R2
round(r2_ml(metaregression_unimoderator_migratory_pop_level)*100,2)


# the equivalent model but without intercept 
# metaregression_unimoderator_migratory_pop_level.nointercept <- rma.mv(yi = yi,
#                                                                       V = VCV.0.50.study_ID,
#                                                                       mod = ~ -1 +
#                                                                         migratory.pop.level,
#                                                                       random = list(~ 1 | species.updated.rep,
#                                                                                     ~ 1 | species.updated,
#                                                                                     ~ 1 | study_ID,
#                                                                                     ~ 1 | population_ID,
#                                                                                     ~ 1 | pair_ID,
#                                                                                     ~ 1 | effectsize_ID),
#                                                                       R = list(species.updated = phylo_cor),
#                                                                       data=body.CV.final,
#                                                                       method="REML",
#                                                                       test="t")
# 
# save(metaregression_unimoderator_migratory_pop_level.nointercept,
#      file="models/metaregression_unimoderator_migratory_pop_level_nointercept.RData")
load("models/metaregression_unimoderator_migratory_pop_level_nointercept.RData")

# getting marginal R2
round(r2_ml(metaregression_unimoderator_migratory_pop_level.nointercept)*100,2)

summary(metaregression_unimoderator_migratory_pop_level.nointercept,3)
round(exp(metaregression_unimoderator_migratory_pop_level.nointercept$beta)*100,2)
round(exp(metaregression_unimoderator_migratory_pop_level.nointercept$ci.lb)*100,2)
round(exp(metaregression_unimoderator_migratory_pop_level.nointercept$ci.ub)*100,2)


################################################################################
# plotting results

orchard.plot.migratory.pop.level <- orchaRd::orchard_plot(metaregression_unimoderator_migratory_pop_level, 
                                                          mod = "migratory.pop.level", 
                                                          group = "species.updated.rep", 
                                                          xlab = "Effect size (CV %)",
                                                          trunk.size = 1.85,
                                                          branch.size = 3.5,
                                                          twig.size = 1.25,
                                                          k.pos = c(4.5,4),
                                                          transfm  = "percent",
                                                          colour = F)
# main text: cropped
orchard.plot.migratory.pop.level.cropped <- orchard.plot.migratory.pop.level + 
  scale_colour_manual(values = c("grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(1,6),
                     breaks = seq(1,6,0.5))

# saving the figure
png(filename = 'figures/supplementary_figures/Figure_S9_Migratory_population_level.png', 
    width = 21, height = 10, units = 'cm', 
    res = 600)

# supplementary material
orchard.plot.migratory.pop.level + 
  scale_colour_manual(values = c("grey50","grey")) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  scale_y_continuous(limits = c(0,14),
                     breaks = seq(0,14,1))

dev.off()


################################################################################
# FEEDING AND MIGRATORY: population-specific
# S4. Calculating total heterogeneity explained
################################################################################

# metaregression_feeding_and_migratory_pop_level <- rma.mv(yi = yi,
#                                                             V = VCV.0.50.study_ID,
#                                                             mod = ~ 1 +
#                                                               migratory.pop.level +
#                                                               feeding.type.pop.level,
#                                                             random = list(~ 1 | species.updated.rep,
#                                                                           ~ 1 | species.updated,
#                                                                           ~ 1 | study_ID,
#                                                                           ~ 1 | population_ID,
#                                                                           ~ 1 | pair_ID,
#                                                                           ~ 1 | effectsize_ID),
#                                                             R = list(species.updated = phylo_cor),
#                                                             data=body.CV.final,
#                                                             method="REML",
#                                                             test="t")
# 
# save(metaregression_feeding_and_migratory_pop_level,
#      file="models/metaregression_feeding_and_migratory_pop_level.RData")
load("models/metaregression_feeding_and_migratory_pop_level.RData")


summary(metaregression_feeding_and_migratory_pop_level,3)

# getting marginal R2
round(r2_ml(metaregression_feeding_and_migratory_pop_level)*100,2)





################################################################################
# Plotting all migration and feeding tests
################################################################################

# FIGURE 2
# saving the figure
png(filename = 'figures/Figure_2_Feeding_and_Migratory_behaviours.png', 
    width = 21, height = 21, units = 'cm', 
    res = 600)

#png(filename = "all.png", width = 9, height = 8, units = "in", type = "windows", res = 400)
orchard.plot.feeding.type.cropped +
  orchard.plot.migratory.cropped +
  orchard.plot.feeding.type.pop.level.cropped +
  orchard.plot.migratory.pop.level.cropped +
  plot_layout(ncol = 2, nrow = 2,
              axes = "collect") + 
  plot_annotation(tag_levels = "A") & 
  theme(plot.tag = element_text(face = "bold"),
        axis.text.y = element_text(angle=90, vjust=0.5, hjust=0.5, size = 8),
        axis.title = element_text(size = 16))

dev.off()